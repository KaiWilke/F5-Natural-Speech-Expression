when RULE_INIT {

	################################################################
	# Configuration Options
	#

	# Configure default action for empty search expressions

	set static::natural_speech_default_action			1		;# bool (0=default deny, 1=default allow)

	# Configure garbage collection interval for Natural Speech

	set static::natural_speech_garbage_collection		120		;# Interval in seconds to clear all existing TCL expressions.

	# Configure Natural Speech alias list. 
	#
	# Note: You have to use two spaces in between combined words!

	set static::natural_speech_alias_list {
		{ not } { - }
		{ and  not } { ! } {not  and } { ! } { but  not } { ! } { but  exempt } { ! } { also  exempt } { ! } { but  deny } { ! } { but  allow } { ! } { also  not } { ! } { also  deny } { ! } { also  allow }  { ! } { nand }  { ! }
		{ nor } { | } { as  well  as } { | } { or } { | }
		{ in  combination  with } { + } { also } { + } { and } { + } { & } { + }
		{ starts_with } { < } { starts  with } { < } { starting  with } { < } { leading  with } { < }
		{ ends_with } { > } { ends  with } { > } { ending  with } { > } { trailing  with } { > }
		{ contains } { <> } { containing } { <> }
		{ equals } { = } { eq } { = } }

	#
	# Configuration Options
	################################################################

	################################################################
	# Garbage collection for cached TCL expressions
	#

	if { $static::natural_speech_garbage_collection > 0 } then {
		
		# Installing a periodic after task job to flush the entire cache every X seconds

		after [expr { $static::natural_speech_garbage_collection * 1000 }] -periodic {

			unset -nocomplain static::natural_speech_cache

		}

	}

	#
	# Garbage Collection for cached Lazy Expressions
	################################################################

}
when HTTP_REQUEST {

	if { [call ::ask_natural_speech_if [HTTP::path] {

                                              equals /

                                      leading with /appfolder/ 
                             and contains /somefolder/ or /anotherfolder/ 
                                  and /deepfolder1/ or /deepfolder2/
                                     and trailing with / or .php 
                                            but exclude 
                                        /evilsomething.php 
                                 or contains /admin/ nor /upload/

                                 starts with /resourcefolder/ 
                               and ends with .jpg or .css or .js

	}] } then {		

		pool mypool

	} else {

		HTTP::respond 403 content "Access Denied" "Content-Type" "text/html"	

	}

}
proc ask_natural_speech_if { input_string search_string } {

	################################################################
	# Procedure Call for Natural Speech Expression verification
	#

	if { [catch {

		################################################################
		# Cached Natural Speech Expression verification
		#

		# Note: By caching the computed TCL expression in a static::* variable, 
		#       subsequent executions of the same search expression can be greatly
		#       accelerated. If a cached version exists, the proc can skip the
		#       CPU-intensive TCL expression construction and also reuse the byte-code
		#       optimized second representation generated by its initial execution. 
		#       The overhead for consecutive executions is a few CPU clicks and almost 
		#       comparable to a native if expression.
		#
		#       The $static::natural_speech_garbage_collection variable defines a
		#       garbage collection interval to delete cached expressions. Adjust
		#       this setting to optimize cache usage. Use a low value if end-users
		#       can define custom searches to prevent LTM memory exhaustion.

		# Trying to load and execute a pre-computed TCL expression from cache

		if $static::natural_speech_cache($search_string) {

			# A pre-computed TCL expression exists in cache and reported a match!

			set result 1

		} else {

			# A pre-computed TCL expression exists in cache  but did not reported a match!

			set result 0

		}

	}] } then {

		################################################################
		# Full interpretation of Natural Speech Expression 
		#

		# A pre-computed Natural Speech Expression does not exist in cache. Performing a full interpretation of the Natural Speech Expression.

		################################################################
		# Sanitization of Natural Speech Expression 
		#
		# Note: Sanitizing the search filter is crucial, as it may be defined by 
		#       an untrusted end-user.
		#
		#       The Natural Speech interpreter is based on controlled double substitution
		#       of a just-in-time compiled TCL expression (JIT). Therefore, we MUST anticipate 
		#       the most malicious user input and escape any byte sequence that allows command 
		#       injection/execution.
		#
		#       The escaping occurs in two stages. The first stage encodes TCL special characters
		#       to URI-encoded sequences at the beginning of construction. The second stage occurs 
		#       in the final TCL expression, where the URI-encoded sequences are replaced with the 
		#       original but backslash (\) escaped values to prevent any form of user-initiated .
		#       substitution. Using two passes is a safety measure, as some list and string based  
		#       commands may silently unescape backslash (\) escapings.
		#
		#       Additionally, the interpreter parses the search expression as a list item. The 
		#       sanitization must verify and repair broken list syntaxes to avoid TCL exceptions 
		#       while processing the search elements.

		# TCL encode the entire search filter to prevent unintended double substitutions.

		set search_list [string map [list {%} {%25} {$} {%24} {[} {%5B} {]} {%5D} "\{" {%7B} "\}" {%7D} {\"} {%22} "\\" {%5C}] $search_string]

		# Input : 'hello     and 		"w o   r \"l d" and"and"or what"ever	or some%\$[]{}thing'
		# Output: 'hello     and 		"w o   r %22l d" and"and"or what"ever	or some%25%5C%24%5B%5D%7B%7Dthing'

		if { [catch {

			################################################################
			# Trying to convert the search string to a functional list item
			#

			# Note: The "lsearch" command is used to format the search string correctly. 
			#       This command removes line breaks, tabs, and unnecessary whitespaces. 
			#       It also transforms quotes to curly braces.
			#
			#       {%00 " %00} encodings are used to escape quoted single words and to
			#       add spaces before and after quotes for stable list operations.
			#       The "%00" sequences will be removed in the final TCL expression.

			# Tagging any quotes while reading the search filter as a list item. This command may fail if an uneven number of quotes is present in the string.

			set search_list [string map { "%00 \{ %00" " \{%00" "%00 \} %00" "%00\} " } [lsearch -inline -all [string map { {"} {%00 " %00} } $search_list] "*" ]]

			# Input : 'hello     and 		"w o   r %22l d" and"and"or whatever	or some%25%5C%24%5B%5D%7B%7Dthing'
			# Output: 'hello and {%00w o   r %22l d%00} and %00and%00 or whatever or some%25%5C%24%5B%5D%7B%7Dthing'

		}] } then {

			################################################################
			# Catch Exemption: Need to fix uneven quotes
			#

			# Catch exception raised due to unequal number of quotes. Retrying last command by URI encoding the last quote character of the search expression.

			set search_list [string map { "%00 \{ %00" " \{%00" "%00 \} %00" "%00\} " } [lsearch -inline -all [string map { {"} {%00 " %00} } [string replace $search_list [set last_quote [string last {"} $search_list]] $last_quote "%22"]] "*" ]]

			# Input : 'hello     and 		"w o   r %22l d" and"and"or what"ever	or some%25%5C%24%5B%5D%7B%7Dthing'
			# Output: 'hello and {%00w o   r %22l d%00} and %00and%00 or what%22ever or some%25%5C%24%5B%5D%7B%7Dthing'

		}

		################################################################
		# URI encode all whitespaces within search string elements
		#

		# URI encoding all white spaces within search string elements to protect them from accidental Natural Speech Alias replacements.

		foreach space_offset [lsearch -all $search_list "* *"] {
			set search_list [lreplace $search_list $space_offset $space_offset [string map { { } {%20} } [lindex $search_list $space_offset]]]
		}

		# Input : 'hello and {%00w%20o   r %22l d%00} and %00and%00 or what%22ever or some%25%5C%24%5B%5D%7B%7Dthing'
		# Output: 'hello and %00w%20o%20%20%20r%20%22l%20d%00 and %00and%00 or what%22ever or some%25%5C%24%5B%5D%7B%7Dthing'

		################################################################
		# Resolving Natural Speech Alias List
		#

		# Double spacing the search list to allow replacements of nearby aliases then resolving the Natural Speech Aliases.

		set search_list [string map $static::natural_speech_alias_list [string map { { } {  } } " $search_list "]]

		# Input : 'hello and %00w%20o%20%20%20r%20%22l%20d%00 and %00and%00 or what%22ever or some%25%5C%24%5B%5D%7B%7Dthing'
		# Output: 'hello  +  %00w%20o%20%20%20r%20%22l%20d%00  +  %00and%00  |  what%22ever  |  some%25%5C%24%5B%5D%7B%7Dthing'

		################################################################
		# Initializing TCL expression construction
		#

		# Already processed instruction set used for look-behind operations.

		set instruction_set ""

		# Positional register is defaulted to "contains"

		set position "contains"

		# Buffer used to construct a given rule chain

		set buffer ""

		# Store to save any completed rule chain.

		set store ""

		################################################################
		# Processing the individual search elements
		#

		foreach element $search_list {

			# Processing next search element...

			if { [string match {[-+|!]} $element] == 1 } then {

				################################################################
				# Processing of search instruction elements
				#

				if { [string match {*[-+|!]} $instruction_set] == 1 } then {

					# Last seen element in instruction set is an instruction. Skipping any duplicated instruction usage.

				} elseif { $instruction_set eq "" } then {

					################################################################
					# Enforcing instruction rules for empty initial instaruction set
					#

					# Instruction set is empty. Enforcing initial instruction set rules. 

					if { $element eq "-" } then {

						# Adding the "-" instruction to the instruction set as a negative rule is about to start.

						set instruction_set "-"

					} elseif { $element eq "!" } then {

						# An instruction set cannot start with a NAND operation. Changing the "!" instruction to a "-" and adding it to the instruction set.

						set instruction_set "-"

					} else {

						# "+|" instructions will be ignored when the instruction set is empty.

					}

				} elseif { $element eq "-" } then {

					################################################################
					# Initialization of new negative rule
					#

					# A negative operator is applied to a non-empty instruction set. Closing the current buffer and storing the rule in the rule store.

					append buffer "\t\t\t)\n\t\t)\n\t)\n"
					lappend store "\n$instruction_set\n" $buffer

					# Set the "-" instruction to the new instruction set and clear the buffer.

					set instruction_set "-"
					set buffer ""

				} else {

					################################################################
					# Processing of +|! instructions
					#

					# Add "+|!" instruction to the instruction set.

					append instruction_set $element

				}

			} elseif { $element eq "<" } then {

				################################################################
				# Processing of STARTS_WITH position register
				#

				# "<" element detected. Setting position register to "starts_with".

				set position "starts_with"

			} elseif { $element eq ">" } then {

				################################################################
				# Processing of ENDS_WITH position register
				#

				# ">" element detected. Setting position register to "ends_with"

				set position "ends_with"

			} elseif { $element eq "<>" } then {

				################################################################
				# Processing of CONTAINS position register
				#

				# "<>" element detected. Setting position register to "contains"

				set position "contains"

			} elseif { $element eq "=" } then {

				################################################################
				# Processing of EQUALS position register
				#

				# "=" element detected. Setting position register to "equals"

				set position "equals"

			} elseif { $instruction_set eq "" } then {

				################################################################
				# Initialization of (initial) positive rule
				#

				# Detected a string element on an empty instruction set. Adding the start snippet of a positive rule to the buffer.

				set instruction_set "e"
				set buffer "\t(\n\t\t(\n\t\t\t(\n\t\t\t\t(\n\t\t\t\t\t\$input_string $position \"$element\"\n\t\t\t\t)\n"

			} elseif { $instruction_set eq "-" } then {

				################################################################
				# Initialization of (initial/next) negative rule 
				#

				# Detected a string element on an empty negative instruction set. Adding the start snippet of a negative rule to the buffer.

				set instruction_set "-e"
				set buffer "\t!(\n\t\t(\n\t\t\t(\n\t\t\t\t(\n\t\t\t\t\t\$input_string $position \"$element\"\n\t\t\t\t)\n"

			} elseif { $instruction_set ends_with "|" } then {

				################################################################
				# Appending of OR operations 
				#

				# Detected a string element on "*|" instruction set. Appending OR snippet to the buffer.

				append instruction_set "e"
				append buffer "\t\t\t\t||\n\t\t\t\t(\n\t\t\t\t\t\$input_string $position \"$element\"\n\t\t\t\t)\n"

			} elseif { $instruction_set ends_with "+" } then {

				################################################################
				# Appending of AND operations  
				#

				# Detected a string element on "*+" instruction set. Appending AND snippet to the buffer.

				append instruction_set "e"
				append buffer "\t\t\t)\n\t\t\t&&\n\t\t\t(\n\t\t\t\t(\n\t\t\t\t\t\$input_string $position \"$element\"\n\t\t\t\t)\n"

			} elseif { $instruction_set ends_with "!" } then {

				################################################################
				# Appending of NAND operations  
				#

				# Detected a string element on "*!" instruction set. Appending NAND snippet to the buffer.

				append instruction_set "e"
				append buffer "\t\t\t)\n\t\t)\n\t\t&& !\n\t\t(\n\t\t\t(\n\t\t\t\t(\n\t\t\t\t\t\$input_string $position \"$element\"\n\t\t\t\t)\n"

			} else {

				################################################################
				# Initialization of (next) positive rule
				#

				# Detected a string element on "*e" instruction set. Appending rule close snippet to the buffer.and saving the finished the rule to rule store. 

				append buffer "\t\t\t)\n\t\t)\n\t)\n"
				lappend store "\n$instruction_set\n" $buffer

				# Initialize a new instruction set to become a positive rule. Setting the start snippet of a positive rule to the buffer.

				set instruction_set "e"
				set buffer "\t(\n\t\t(\n\t\t\t(\n\t\t\t\t(\n\t\t\t\t\t\$input_string $position \"$element\"\n\t\t\t\t)\n"

			}
		}

		# Finished processing all search elements...

		################################################################
		# Closing last processed rule
		#

		if { $buffer ne "" } then {

			# Appending rule close snippet to the buffer.and saving the finished the rule to rule store. 

			append buffer "\t\t\t)\n\t\t)\n\t)\n"
			lappend store "\n$instruction_set\n" $buffer

		}

		################################################################
		# Joining stored rules into final TCL expression
		#

		if { $store ne "" } then {

			# The rule store contains at least one rule. Combining all existing positive and negative rules into a final TCL expression.

			set combined ""

			# Fetching all positive rules from the store and joining them using OR operators.

			set positive [join [lsearch -all -inline $store "\t(*"] "\t||\n"]

			if { $positive ne "" } then {

				# Adding the positive rules to the combined store

				lappend combined $positive

			}

			# Fetching all negative rules from the store and joining them using AND operators.

			set negative [join [lsearch -all -inline $store "\t!(*"] "\t&&\n"]

			if { $negative ne "" } then {

				# Adding the nagative rules to the combined store

				lappend combined $negative

			}

			################################################################
			# Writing final TCL expression to Natural Speech Expression Cache
			#

			# Fetching all negative rules from the store and joining them using AND operators.
			
			# Joining the combined positive and negative rules with AND operators to form the final TCL expression and applying TCL encoding to it.

			# Note: The URI-encoded sequences are being decoded into TCL-encoded 
			#       values. Any TCL-specific character sequence that may disrupt 
			#       the format of the TCL expression or access $vars or execute
			#       [commands] will be escaped with a backslash (\).

			set static::natural_speech_cache($search_string) [string map [list {%25} {%} {%24} {\$} {%5B} {\[} {%5D} {\]} {%7B} "\\\{" {%7D} "\\\}" {%5C} "\\\\" {%00} {} {%20} { } {%22} {\"}] "(\n[join $combined ")\n&&\n(\n"])\n"]

		} else {

			################################################################
			# Writing default TCL expression to Natural Speech Expression Cache 
			#

			set static::natural_speech_cache($search_string) $static::natural_speech_default_action

		}

		################################################################
		# Initial TCL expression execution, byte-compilation and verification
		#

		# Executing the TCL expression from global cache for the first time

		if $static::natural_speech_cache($search_string) {

			# The TCL expression reported a match!

			set result 1 

		} else {

			# The TCL expression did not reported a match!

			set result 0

		}

	}

	################################################################
	# Return the verification result back to procedure call
	#

	return $result

}
